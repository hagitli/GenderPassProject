# -*- coding: utf-8 -*-
"""GenPredUtils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UXqgFy_CjtJo8pTVAv97WanvIQdg4vrQ
"""

def user_entities(usernames):
  u_ent = []
  c=0
  for u in usernames:
    u = split_uname(u)
    ent = get_entites_from_text(u)
    u_ent.append((u,ent))
    c+=1
    if (c%1000 == 0): print (c)
  return u_ent

def count_male_female(u_ent):
  c = 0
  male = 0
  female = 0
  for uent in u_ent:
    if (len (uent[1]) ) > 0:
      k =list(uent[1].keys())[0]
      ent = list(uent[1][k])[0]
      ent = ent.capitalize().strip()
      c +=1
      gg= d.get_gender(ent)
      if (gg == "male"):
        male +=1
      else:
        if (gg == "female"):
          female +=1
          
  return c, male, female

def get_password_compexity_metrics_pd(password):
  numbers = sum(c.isdigit() for c in password)
  capitals = sum(1 for c in password if c.isupper())
  lowers = sum(1 for c in password if c.islower())
  special_chars = string.punctuation
  chars = sum(v for k, v in ct.Counter(password).items() if k in special_chars)
  grade = 1
  strength = -1
  if (numbers>0 and capitals>0 and lowers>0):
    grade = 3
  else:
    if (numbers>0 and capitals>0) or (numbers>0 and lowers>0) or (lowers>0 and capitals>0):
      grade = 2
  try:
    strength = PasswordStats(password).strength()
  except:
    pass  
  return [numbers,capitals,lowers,chars, grade,strength]  

def get_password_compexity_metrics(password):
  numbers = sum(c.isdigit() for c in password)
  capitals = sum(1 for c in password if c.isupper())
  lowers = sum(1 for c in password if c.islower())
  special_chars = string.punctuation
  chars = sum(v for k, v in ct.Counter(password).items() if k in special_chars)
  grade = 1
  strength = -1
  if (numbers>0 and capitals>0 and lowers>0):
    grade = 3
  else:
    if (numbers>0 and capitals>0) or (numbers>0 and lowers>0) or (lowers>0 and capitals>0):
      grade = 2
  try:
    strength = PasswordStats(password).strength()
  except:
    pass  
  return (numbers,capitals,lowers,chars, grade,strength)  


def get_password_compexity_metrics_ext(password):
  numbers = sum(c.isdigit() for c in password)
  capitals = sum(1 for c in password if c.isupper())
  lowers = sum(1 for c in password if c.islower())
  special_chars = string.punctuation
  chars = sum(v for k, v in ct.Counter(password).items() if k in special_chars)
  grade = 1
  strength = -1
  if (numbers>0 and capitals>0 and lowers>0):
    grade = 3
  else:
    if (numbers>0 and capitals>0) or (numbers>0 and lowers>0) or (lowers>0 and capitals>0):
      grade = 2
  try:
    strength = PasswordStats(password).strength()
  except:
    pass  
  return (numbers,capitals,lowers,chars, grade,strength)  

  pip install randtest

def get_gender_from_namesDictionary (q_name, t_hold=0.8):
  final_gender = 'unknown'
  f_qname_sum = 0
  m_qname_sum = 0
  female_retio = 0
  male_retio = 0
  # First we filter seb-list of all records that related to the given name and their quantities
  total_qname = names.filter_by(q_name, 'Name')
  # We split them to female names set and for male names set
  f_qname = total_qname[total_qname['Gender'] == 'F']
  m_qname = total_qname[total_qname['Gender'] == 'M']
  # Now we check how many times the name was given for each gender:
  if (len(f_qname)>0):
  # We sum all occurrences of females for the given name in the dataset
    f_qname_sum = f_qname.groupby(['Name','Gender'],operations={'sum':agg.SUM('Count')})['sum'][0]
  if (len(m_qname) > 0):
  # We sum all occurrences of males for the given name in the dataset  
    m_qname_sum = m_qname.groupby(['Name','Gender'],operations={'sum':agg.SUM('Count')})['sum'][0]
  # Now we check the retio of males and females for the given name, by dividing each gender occurrences in the total sum.
  if (m_qname_sum > f_qname_sum): 
    # This is if there are more males than females for the given name:
    male_retio = m_qname_sum/(m_qname_sum+f_qname_sum)
    if (male_retio > t_hold):
      final_gender = 'Male'
  if (f_qname_sum > m_qname_sum):
    # This is if there are more females than males for the given name:
    female_retio = f_qname_sum/(m_qname_sum+f_qname_sum) 
    if (female_retio > t_hold):
      final_gender = 'Female'
  # Finally, returns the final gender by majority according to threshold  
  return (final_gender, male_retio,female_retio)

def set_gender_by_dict(u):
  l = split_uname(u)
  l = l.capitalize()
  g = get_gender_from_namesDictionary(l)[0]
  return g

def create_entity_dict(u_names):
  entity_dict = {}
  for u in u_names:
    entity = get_entites_from_text(u)
    entity_dict[u] = entity
  return entity_dict

def create_person_dict(entity_dict):
  person_dict = {}
  for k, v in entity_dict.items():
    if (len(v) > 0):
      item = v.get('PERSON')
      if (item != None):
        try:
          g = names_dict[k]
          person_dict[k] = g
          found +=1
        except:
          person_dict[k] = "unknown"

def get_gender_from_entity_dict(x):
  try:
    g = person_dict[x]
  except:
    g = "unknown"
  return g
sf['gender_by_entity'] =  sf['f_name'].apply(lambda x: get_gender_from_entity_dict(x))

#building NamesDirectory
def build_NamesDictionary():
  names = tc.SFrame.read_csv("/content/NationalNames.csv") #this is the source file of names
  uniq_names = names['Name'].unique() #we take unique names
  names_dict = {} #initialize dictionary
  for u in uniq_names:
    gender = get_gender_from_namesDictionary(u)[0] #for each name, get its gender (determined by majority of at least 0.8 for gender)
    names_dict[u] = gender

def get_gender_from_names_dict(x):
  try:
    g = names_dict[x]
  except:
    g = "unknown"
  return g